##### JS225 > Function Contexts and Objects

---

# Practice Problems: Implicit and Explicit Function Execution Contexts

1. What will the code below output?

   ```javascript
   function foo() {
     return this;
   }
   
   let context = foo();
   console.log(context);
   ```

   ##### Solution

   The code logs the browser's global object, `Window`. That looks something like this in the Chrome Console:

   ```node
   Window { /* a bunch of key/value pairs */ }
   ```

   The return value of the `foo` function is the value of the global object (`global`). We assign context to that variable, then display it to show the value of `global`.

2. What will the code in the previous question output in strict mode?

   ##### Solution

   ```javascript
   undefined
   ```

   The return value of `foo` is the global `this`, which is undefined in strict mode.

3. What will the code below output? Explain the difference, if any, between this output and that of problem 1.

   ```javascript
   let obj = {
     foo() {
       return this;
     },
   };
   
   let context = obj.foo();
   
   console.log(context);
   ```

   ##### Solution

   ```javascript
   {foo: f}
   ```

   Unlike problem 1, this code outputs the object `obj`. This happens since `foo` is invoked as a *method*. Thus, its execution context refers to the object used to call the function.

4. What will the code below output?

   ```javascript
   var message = 'Hello from the global scope!';
   
   function deliverMessage() {
     console.log(this.message);
   }
   
   deliverMessage();
   
   let bar = {
     message: 'Hello from the function scope!',
   };
   
   bar.deliverMessage = deliverMessage;
   
   bar.deliverMessage();
   ```

   ##### Solution

   ```plaintext
   Hello from the global scope!
   Hello from the function scope!
   ```

   The first log operation is generated by the *function* call, `deliverMessage()` on line 7. Since this is a function invocation, the implicit function execution context is the global object, `Window`. That means that JavaScript looks in `Window` for the variable `message`.

   The second log operation is generated by the *method* call `bar.deliverMessage()` on line 15. Since the implicit function execution context for a method invocation is the calling object, `this` resolves to `bar`, and `this.message` resolves to `bar`'s property `message`.

5. What will the code below output? What would happen if we replaced `var` on line 1 with `let`? Can you explain why the output changes?

   ```javascript
   var a = 10;
   let b = 10;
   let c = {
     a: -10,
     b: -10,
   };
   
   function add() {
     return this.a + b;
   }
   
   c.add = add;
   
   console.log(add());
   console.log(c.add());
   ```

   ##### Solution

   **With `var` on line 1**

   ```plaintext
   20
   0
   ```

   **With `let` on line 1**

   ```plaintext
   NaN
   0
   ```

   As in question 3, the key detail here is that the first invocation of `add` is as a function, while the second invocation is as a method. In the function invocation, on line 14, `this` resolves to the global object, and the property `a` to the value `10`. In the method invocation, however, `this` resolves to the object `c`, and the property `a` to the value `-10`. In both cases a simple reference to `b`.

   When we replaced `var` with `let`, the output of the function call is `NaN`, not `20`. This happens because global `var` variables create properties on the global object, but `let` and `const` create variables that don't belong to any object.

6. The problems above all feature *implicit* function execution context. What methods have we learned so far that let us explicitly specify what a function's execution context should be?

   ##### Solution

   The `Function` methods `call` and `apply` let us explicitly set the function execution context.

7. In the code below, use `call` to invoke `add` as a method on `bar`, but with `foo` as the execution context. What will this return?

   ```javascript
   let foo = {
     a: 1,
     b: 2,
   };
   
   let bar = {
      a: 'abc',
      b: 'def',
      add() {
        return this.a + this.b;
      },
   };
   ```

   ##### Solution

   ```javascript
   bar.add.call(foo); // 3
   ```

   Since we are invoking `call` on `bar.add` and supplying the object `foo` as explicit context, `foo`'s properties `a` and `b`, rather than `bar`'s, will be referenced during execution, returning a value of `3`.

8. Given the code and desired output shown below, should you use `call` or `apply` to supply explicit context and the arguments to `outputList`? That is, which method makes the most sense to use? Implement a solution using your preferred method such that the desired output is logged, and explain your choice.

   ```javascript
   let fruitsObj = {
     list: ['Apple', 'Banana', 'Grapefruit', 'Pineapple', 'Orange'],
     title: 'A Collection of Fruit',
   };
   
   function outputList() {
     console.log(this.title + ':');
   
     let args = [].slice.call(arguments);
   
     args.forEach(function(elem) {
       console.log(elem);
     });
   }
   
   // invoke outputList here
   ```

   Desired output:

   ```plaintext
   A Collection of Fruit:
   Apple
   Banana
   Grapefruit
   Pineapple
   Orange
   ```

   ##### Solution

   ```javascript
   outputList.apply(fruitsObj, fruitsObj.list);
   ```

   `apply` takes an array of arguments to be passed to the invoked function, rather than `call`'s comma-separated arguments. Since the data we are concerned with (`fruitsObj.list`) is held in Array format, it makes more sense to use `apply`.

   A more modern solution for this problem uses `call` and the new "spread syntax":

   ```javascript
   outputList.call(fruitsObj, ...fruitsObj.list);
   ```

   

